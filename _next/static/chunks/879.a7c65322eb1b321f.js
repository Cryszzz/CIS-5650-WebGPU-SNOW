(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[879],{1879:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return main}});var a=n(6416),r=n(5893),i=n(9008),o=n.n(i),s=n(1163),l=n(7294),u=n(4131),c=n.n(u);n(6876);let SampleLayout=e=>{let t=(0,l.useRef)(null),a=(0,l.useMemo)(()=>e.sources.map(e=>{let{name:t,contents:a}=e;return{name:t,...function(e){let t;let a=null;{a=document.createElement("div");let e=n(4631);t=e(a,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(n){return(0,r.jsx)("div",{...n,children:(0,r.jsx)("div",{ref:n=>{a&&n&&(n.appendChild(a),t.setOption("value",e))}})})}}}(a)}}),e.sources),i=(0,l.useRef)(null),u=(0,l.useMemo)(()=>{if(e.gui){let e=n(4376),t=new e.GUI({autoPlace:!1});return t.domElement.style.position="relative",t.domElement.style.zIndex="1000",t}},[]),m=(0,l.useRef)(null),d=(0,l.useMemo)(()=>{if(e.stats){let e=n(2792);return new e}},[]),f=(0,s.useRouter)(),g=f.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[p,h]=(0,l.useState)(null),[x,v]=(0,l.useState)(null);return(0,l.useEffect)(()=>{if(g?v(g[1]):v(a[0].name),u&&i.current)for(i.current.appendChild(u.domElement);u.__controllers.length>0;)u.__controllers[0].remove();d&&m.current&&(d.dom.style.position="absolute",d.showPanel(1),m.current.appendChild(d.dom));let n={active:!0};try{let a=t.current;if(!a)throw Error("The canvas is not available");let r=e.init({canvas:a,pageState:n,gui:u,stats:d});r instanceof Promise&&r.catch(e=>{console.error(e),h(e)})}catch(e){console.error(e),h(e)}return()=>{n.active=!1}},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(o(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description}),(0,r.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,r.jsxs)("div",{className:c().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",left:10},ref:m}),(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:i}),(0,r.jsx)("canvas",{ref:t})]})]})},makeSample=e=>(0,r.jsx)(SampleLayout,{...e});var m="struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n@binding(1) @group(0) var mySampler: sampler;\n@binding(2) @group(0) var myTexture: texture_cube<f32>;\n\nconst skybox_size=3000.0;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vs_main(\n  @location(0) position : vec4<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  var cam=uniforms.modelViewProjectionMatrix;\n  output.Position =  uniforms.modelViewProjectionMatrix*vec4<f32>(position.xyz*skybox_size,1.0);\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n\n@fragment\nfn fs_main(\n  @location(0) fragUV: vec2<f32>,\n  @location(1) fragPosition: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var cubemapVec = fragPosition.xyz - vec3(0.5);\n  var color=textureSample(myTexture, mySampler, cubemapVec);\n  return color;\n}";let d=new Float32Array([1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,1,0,1,-1,-1,1,1,0,0,1,0,0,1,-1,1,1,1,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,-1,1,1,1,0,1,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,1,-1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,-1,-1,1,1,0,0,1,1,0,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,-1,1,-1,1,0,1,0,1,0,0,-1,1,1,1,0,1,1,1,0,1,1,1,-1,1,1,1,0,1,1,0,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,-1,1,-1,1,0,1,0,1,1,0,-1,-1,-1,1,0,0,0,1,0,0,-1,-1,1,1,0,0,1,1,0,1,-1,1,-1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,0,-1,-1,1,1,0,0,1,1,1,0,1,-1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,-1,-1,1,1,0,0,1,0,1,-1,-1,-1,1,0,0,0,1,1,1,-1,1,-1,1,0,1,0,1,1,0,1,1,-1,1,1,1,0,1,0,0,1,-1,-1,1,1,0,0,1,0,1,-1,1,-1,1,0,1,0,1,1,0]);async function createSkyboxPipeline(e,t){return e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:m}),entryPoint:"vs_main",buffers:[{arrayStride:40,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:32,format:"float32x2"}]}]},fragment:{module:e.createShaderModule({code:m}),entryPoint:"fs_main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}})}async function loadCubemapTexture(e){var t;let n=["../assets/img/cubemap/sky2px.png","../assets/img/cubemap/sky2nx.png","../assets/img/cubemap/sky2py.png","../assets/img/cubemap/sky2ny.png","../assets/img/cubemap/sky2pz.png","../assets/img/cubemap/sky2nz.png"].map(async e=>{let t=await fetch(e);return createImageBitmap(await t.blob())}),a=await Promise.all(n);t=e.createTexture({dimension:"2d",size:[a[0].width,a[0].height,6],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let n=0;n<a.length;n++){let r=a[n];e.queue.copyExternalImageToTexture({source:r},{texture:t,origin:[0,0,n]},[r.width,r.height])}return t}async function renderSkybox(e,t,n,a,r,i,o){e.queue.writeBuffer(a,0,o.buffer,o.byteOffset,o.byteLength),i.setPipeline(t),i.setVertexBuffer(0,n),i.setBindGroup(0,r),i.draw(36)}var f='////////////////////////////////////////////////////////////////////////////////\n// Utilities\n////////////////////////////////////////////////////////////////////////////////\nvar<private> rand_seed : vec2<f32>;\nconst albedo = vec3<f32>(0.9,0.7,0.4);\nconst PI:f32=3.1416926535928;\nstruct SimulationCS {\n    MeasurementAltitude: f32,\n    TSnowA:f32,\n    TSnowB:f32,\n    TMeltA:f32,\n    TMeltB:f32,\n    k_e:f32,\n    k_m:f32,\n    meltFactor:f32,\n};\nconst SimulationCSConstants: SimulationCS = SimulationCS(0.0,0.0,2.0,-5.0,-2.0,0.2,4.0, 2.0);\n\nstruct ConfigurationCS {\n  posNormalizeFactor: f32,\n  posMax: f32,\n  colorMaxScaleFactor: f32,\n  areaScaleFactor: f32,\n  r_i_tScaleFactor: f32,\n  maxSWE: f32,\n  temperatureLapseNormalizeFactor: f32,\n  precipitationLapseNormalizeFactor: f32,\n};\n\nstruct WeatherData\n{\n	Temperature:f32,\n	Precipitation:f32,\n};\n\nstruct SimulationCSVar {\n    Timesteps: f32,\n    CurrentSimulationStep: f32,\n    HourOfDay: f32,\n    DayOfYear: f32,\n};\n\nconst SimulationCSVariables: SimulationCSVar = SimulationCSVar(0,0,12,35);\n\nfn init_rand(invocation_id : u32, seed : vec4<f32>) {\n  rand_seed = seed.xz;\n  rand_seed = fract(rand_seed * cos(35.456+f32(invocation_id) * seed.yw));\n  rand_seed = fract(rand_seed * cos(41.235+f32(invocation_id) * seed.xw));\n}\n\nfn rand() -> f32 {\n  rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);\n  rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);\n  return rand_seed.y;\n}\n\nfn Func2(L: f32, D: f32) -> f32 {\n    return acos(clamp(-tan(L) * tan(D), -1.0, 1.0));\n}\n\nfn Func3(V: f32, W: f32, X: f32, Y: f32, R1: f32, D: f32) -> f32 {\n    return R1 * (sin(D) * sin(W) * (X - Y) * (12.0 / PI) +\n                 cos(D) * cos(W) * (sin(X + V) - sin(Y + V)) * (12.0 / PI));\n}\n\nfn SolarRadiationIndex(I: f32, A: f32, L0: f32, J: f32) -> vec3<f32>{\n    var L1: f32 = acos(cos(I) * sin(L0) + sin(I) * cos(L0) * cos(A));\n    var D1: f32 = cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A);\n    var L2: f32 = atan(sin(I) * sin(A) / (cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A)));\n\n    var D: f32 = 0.007 - 0.4067 * cos((J + 10.0) * 0.0172);\n    var E: f32 = 1.0 - 0.0167 * cos((J - 3.0) * 0.0172);\n\n    let R0: f32 = 1.95;\n    var R1: f32 = 60.0 * R0 / (E * E);\n\n    var T: f32;\n    T = Func2(L1, D);\n    var T7: f32 = T - L2;\n    var T6: f32 = -T - L2;\n    T = Func2(L0, D);\n    var T1: f32 = T;\n    var T0: f32 = -T;\n    var T3: f32 = min(T7, T1);\n    var T2: f32 = max(T6, T0);\n\n    var T4: f32 = T2 * (12.0 / PI);\n    var T5: f32 = T3 * (12.0 / PI);\n\n    if (T3 < T2) {\n        T2 = 0.0;\n        T3 = 0.0;\n    }\n\n    T6 = T6 + PI * 2.0;\n\n    var R4: f32;\n    if (T6 < T1) {\n        var T8: f32 = T6;\n        var T9: f32 = T1;\n        R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);\n    } else {\n        T7 = T7 - PI * 2.0;\n\n        if (T7 > T0) {\n            var T8: f32 = T0;\n            var T9: f32 = T0;\n            R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);\n        } else {\n            R4 = Func3(L2, L1, T3, T2, R1, D);\n        }\n    }\n\n    var R3: f32 = Func3(0.0, L0, T1, T0, R1, D);\n\n    return vec3<f32>(T4,T5,R4 / R3);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Vertex shader\n////////////////////////////////////////////////////////////////////////////////\nstruct RenderParams {\n  modelViewProjectionMatrix : mat4x4<f32>,\n  campos : vec3<f32>,\n  fogStart:f32,\n  up : vec2<f32>,\n  fogEnd:f32,\n  heightMul : f32,\n  configurationCSVariables: ConfigurationCS,\n}\n@binding(0) @group(0) var<uniform> render_params : RenderParams;\n@binding(1) @group(0) var fragtexture : texture_2d<f32>;\n@binding(2) @group(0) var origtexture : texture_2d<f32>;\n@binding(3) @group(0) var<uniform>  grid : vec2<f32>;\n@binding(4) @group(0) var heighttexture : texture_2d<f32>;\n@binding(5) @group(0) var<storage, read> maxSnow : array<u32>; // TODO: BINDING NUMBER\n\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : f32,\n  @location(2) uv: vec2<f32>, // -1..+1\n}\n\nstruct VertexOutput {\n  @location(0) position: vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>, // -1..+1\n\n  @builtin(position) Position : vec4<f32>,\n}\nconst heightMul:f32=0.01;\n@vertex\nfn vs_main(in : VertexInput,\n            @builtin(instance_index) instance: u32) -> VertexOutput {\n  //var quad_pos = mat2x3<f32>(render_params.right, render_params.up) * in.quad_pos;\n  //var position = in.position;\n\n  // var in_position_height_offset = vec3<f32>(in.position.x, in.position.y + testColorMax.x, in.position.z);\n\n  var out : VertexOutput;\n  \n  var textDim=vec2<i32>(textureDimensions(heighttexture));\n  //textDim=vec2<i32>(5,5);\n  let i = i32(instance);\n  let cell = vec2<i32>(i % (textDim.x - 1), i / (textDim.x - 1)); // should one be textDim.y - 1?\n  let p0:vec3<f32>=vec3<f32>(0.0,textureLoad(heighttexture,cell,0).x*render_params.heightMul,0.0);\n  let p1:vec3<f32>=vec3<f32>(grid.x,textureLoad(heighttexture,vec2<i32>(cell.x+1,cell.y),0).x*render_params.heightMul,0.0);\n  let p2:vec3<f32>=vec3<f32>(0.0,textureLoad(heighttexture,vec2<i32>(cell.x,cell.y+1),0).x*render_params.heightMul,grid.y);\n  let p3:vec3<f32>=vec3<f32>(grid.x,textureLoad(heighttexture,vec2<i32>(cell.x+1,cell.y+1),0).x*render_params.heightMul,grid.y);\n  /*let p0:vec3<f32>=vec3<f32>(0.0,0.0,0.0);\n  let p1:vec3<f32>=vec3<f32>(grid.x,30.0,0.0);\n  let p2:vec3<f32>=vec3<f32>(0.0,30.0,grid.y);\n  let p3:vec3<f32>=vec3<f32>(grid.x,90.0,grid.y);*/\n  var normal:vec3<f32>;\n  if(in.normal==0.0){\n    normal=normalize(cross(p2-p0,p3-p0));\n  }else{\n    normal=normalize(cross(p3-p0,p1-p0));\n  }\n  var coord:vec2<i32>=cell;\n  if(in.position.x > 0.0){\n    coord.x+=1;\n  }\n  if(in.position.z > 0.0){\n    coord.y+=1;\n  }\n  //let cell = vec2<i32>(i % 2, i / 2);\n\n  // Calculate displacement from snow\n  var fragDim=vec2<i32>(textureDimensions(fragtexture).xy);\n  var fragCoord : vec2<i32>=vec2<i32>(0,0);\n  fragCoord.x=i32(f32(coord.x) / f32(textDim.x) * f32(fragDim.x)); \n  fragCoord.y=i32(f32(coord.y) / f32(textDim.y) * f32(fragDim.y));  \n\n  var testcolor = textureLoad(fragtexture, fragCoord.xy, 0); \n  var testColorFirst = testcolor / render_params.configurationCSVariables.posNormalizeFactor;\n  var testColorMax = clamp(testColorFirst * render_params.configurationCSVariables.posMax * 10.0, vec4(0.0), vec4(render_params.configurationCSVariables.posMax)); // change these values so that they can be multiplied by render_params.heightMul\n  let cellOffset = vec2<f32>(cell-textDim/2)*grid;\n  var gridPos:vec2<f32> = (in.position.xz) * (grid/2.0) + cellOffset;\n  \n  var height:f32=textureLoad(heighttexture,coord,0).x;\n  out.Position = render_params.modelViewProjectionMatrix * vec4<f32>(gridPos.x,(height + testColorMax.x)*render_params.heightMul,gridPos.y, 1.0);\n  out.position=vec3<f32>(gridPos.x,(height + testColorMax.x)*render_params.heightMul,gridPos.y);\n  out.normal =normal;\n  out.uv = vec2<f32>(f32(coord.x)/f32(textDim.x),f32(coord.y)/f32(textDim.y));\n  return out;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fragment shader\n////////////////////////////////////////////////////////////////////////////////\n\nconst lightPos : vec3<f32>= vec3<f32> (50.0, 100.0, -100.0);\nconst lightDir : vec3<f32>= vec3<f32> (1.0, -1.0, 0.0);\nconst ambientFactor = 0.4;\n/*\nCRYSTAL: There are two texture bind to fragment shader\nfragtexture: the texture buffer that got from compute pipeline\norigtexture: the texture buffer that is the original texture\n\nThey varies in resolution, better to interpolate values for final result, but rn, change between these two to test whether we have correct computation.\n*/\nconst fogColor:vec3<f32> =vec3<f32>(0.5,0.5,0.5);\n\n@fragment\nfn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {\n  var test=render_params.modelViewProjectionMatrix;\n  var textDim=vec2<i32>(textureDimensions(fragtexture).xy);\n  var textorigDim=vec2<i32>(textureDimensions(origtexture).xy);\n  var coord : vec2<i32>=vec2<i32>(0,0);\n\n  //CRYSTAL: change following three lines of code for testing different textures\n  coord.x=i32(f32(textDim.x)*in.uv.x);\n  coord.y=i32(f32(textDim.y)*in.uv.y);\n  var testcolor = textureLoad(fragtexture, coord.xy, 0);\n\n  coord.x=i32(f32(textorigDim.x)*in.uv.x);\n  coord.y=i32(f32(textorigDim.y)*in.uv.y);\n  var origcolor = textureLoad(origtexture, coord.xy, 0);\n\n  // this should be maxSnow[0] instead of maxSnow[0] * 0.4, but leaving it here until debugged\n  // var testColorMaxFirst = clamp(testcolor / (f32(maxSnow[0]) * 0.35), vec4(0.0), vec4(1.0));\n  var testColorMaxFirst = testcolor / (f32(maxSnow[0]) * render_params.configurationCSVariables.colorMaxScaleFactor);\n  var testColorMaxScaled = select(testColorMaxFirst * 1.75, testColorMaxFirst * 0.75 + 0.20, testColorMaxFirst.x > 0.2); \n  var testcolorMax = clamp(testColorMaxScaled, vec4(0.0), vec4(1.0));\n  // var out_color = testcolorMax;\n  // var out_color = testcolor;\n  var out_color = (1.0-testcolorMax.x)*origcolor+testcolorMax.x*testcolorMax;\n  // var out_color = vec4(maxSnow[0]);\n\n  let lambertFactor = max(dot(normalize(-lightDir), in.normal), 0.0);\n  let lightingFactor = min(ambientFactor + lambertFactor, 1.0);\n  var color = vec4(lightingFactor*out_color.xyz,1.0);\n  var fogStart:f32 =render_params.fogStart;\n  var fogEnd:f32 =render_params.fogEnd;\n  let fogFactor:f32= clamp((fogEnd-length(render_params.campos-in.position))/(fogEnd-fogStart),0.0,1.0);\n  let fogColorVec4: vec4<f32> =vec4<f32>(fogColor,1.0);\n  let colorWithFog:vec4<f32>=mix(fogColorVec4,color,fogFactor);\n  // var color = vec4(out_color.xyz,1.0);\n  // Apply a circular particle alpha mask\n  //color.a = color.a * max(1.0 - length(in.quad_pos), 0.0);\n  return colorWithFog;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Simulation Compute shader\n////////////////////////////////////////////////////////////////////////////////\n\nstruct SimulationParams {\n  simulationCSConstants: SimulationCS,\n  simulationCSVariables: SimulationCSVar,\n  configurationCSVariables: ConfigurationCS,\n  temperature: f32,\n  precipitation: f32,\n}\n\nstruct Particle {\n  position : vec3<f32>,\n  lifetime : f32,\n  color    : vec4<f32>,\n  velocity : vec3<f32>,\n}\nstruct Particles {\n  particles : array<Particle>,\n}\n\nstruct Cell { \n  Aspect: f32,\n  Inclination: f32,\n  Altitude: f32,\n  Latitude: f32,\n  Area: f32,\n  AreaXY: f32,\n  SnowWaterEquivalent: f32,\n  InterpolatedSWE: f32,\n  SnowAlbedo: f32,\n  DaysSinceLastSnowfall: f32,\n  Curvature: f32,\n  Padding:f32,\n}\nstruct Cells {\n  cells : array<Cell>,\n}\n\n@binding(0) @group(0) var<uniform> simParams : SimulationParams;\n@binding(1) @group(0) var<storage, read_write> data : Cells;\n@binding(2) @group(0) var texture : texture_2d<f32>;\n@binding(3) @group(0) var texture2 : texture_storage_2d<rgba32float, write>;\n@binding(4) @group(0) var<storage, read_write> maxSnowStorage : array<atomic<u32>>;\n\n@compute @workgroup_size(8,8)\nfn simulate(@builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n    \n    var textDim=vec2<i32>(textureDimensions(texture).xy);\n    var text2Dim=vec2<i32>(textureDimensions(texture2).xy);\n    var coord : vec2<i32>=vec2<i32>(global_invocation_id.xy);\n    var idx: u32= global_invocation_id.y*textureDimensions(texture2).x+global_invocation_id.x;\n    //var idx: u32= global_invocation_id.x;\n\n    // init_rand(idx, simParams.seed);\n    var loadcoord : vec2<i32>=vec2<i32>(0,0);\n    loadcoord.x=i32(coord.x*textDim.x/text2Dim.x);\n    loadcoord.y=i32(coord.y*textDim.y/text2Dim.y);\n    //CRYSTAL: color from original texture\n    var color = textureLoad(texture, loadcoord, 0);\n    \n    //CRYSTAL: here is example of how to store color to texture, just modify color.xyz to change color\n    // if (coord)\n    // textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(color.xyz,1.0));\n\n\n    //CRYSTAL: starting from this part, use the same code from that unreal project\n    var celldata = data.cells[idx];\n    \n    var areaSquareMeters:f32 = celldata.AreaXY * simParams.configurationCSVariables.areaScaleFactor; // m^2 \n    // var areaSquareMetersPrecip:f32 = celldata.AreaXY / 1000; // m^2\n\n    //for (var time:i32 = 0; time < SimulationCSVariables.Timesteps; time=time+1) {\n    var stationAltitudeOffset:f32 = celldata.Altitude - simParams.simulationCSConstants.MeasurementAltitude;\n    var temperatureLapse:f32 = - (0.5 * stationAltitudeOffset) / (simParams.configurationCSVariables.temperatureLapseNormalizeFactor);\n\n    var tAir:f32= simParams.temperature + temperatureLapse; // degree Celsius\n    // var tAir:f32= simParams.temperature;\n\n    var precipitationLapse:f32= 10.0 / 24.0 * stationAltitudeOffset / (simParams.configurationCSVariables.precipitationLapseNormalizeFactor);\n        // const precipitationLapse: number = 0;\n    var precipitation:f32 = simParams.precipitation;\n\n    celldata.DaysSinceLastSnowfall += 1.0 / 24.0;\n    \n    var output_color_debug = 0.1;\n\n      // Apply precipitation\n    if (precipitation > 0.0) {\n        precipitation += precipitationLapse;\n        celldata.DaysSinceLastSnowfall = 0.0;\n\n        // New snow/rainfall\n        //let rain: boolean = tAir > SimulationCSConstants.TSnowB;\n\n        if (tAir > simParams.simulationCSConstants.TSnowB) {\n            celldata.SnowAlbedo = 0.4; // New rain drops the albedo to 0.4\n        } else {\n            // Variable lapse rate as described in "A variable lapse rate snowline model for the Remarkables, Central Otago, New Zealand"\n            var snowRate:f32= max(0.0, 1.0 - (tAir - simParams.simulationCSConstants.TSnowA) / (simParams.simulationCSConstants.TSnowB - simParams.simulationCSConstants.TSnowA));\n\n            celldata.SnowWaterEquivalent += (precipitation * areaSquareMeters * snowRate); // l/m^2 * m^2 = l\n            // celldata.SnowWaterEquivalent += (precipitation * snowRate); // l/m^2 * m^2 = l\n            celldata.SnowAlbedo = 0.8; // New snow sets the albedo to 0.8\n        }\n    }\n      \n      // Apply melt\n    if (celldata.SnowWaterEquivalent > 0.0) {\n        if (celldata.DaysSinceLastSnowfall >= 0.0) {\n            celldata.SnowAlbedo = 0.4 * (1.0 + exp(-simParams.simulationCSConstants.k_e * celldata.DaysSinceLastSnowfall));\n        }\n\n        // Temperature higher than melt threshold and cell contains snow\n        if (tAir > simParams.simulationCSConstants.TMeltA) {\n            var dayNormalization: f32 = 1.0 / 24.0; // day\n\n            // Radiation Index\n            var output: vec3<f32> = SolarRadiationIndex(celldata.Inclination,celldata.Aspect, celldata.Latitude, f32(simParams.simulationCSVariables.DayOfYear)); // 1\n\n            var r_i:f32=output.z;\n            var T4: f32=output.x;\n            var T5: f32=output.y;\n\n            // Diurnal approximation\n            var t: f32 = simParams.simulationCSVariables.HourOfDay;\n            var D: f32 = abs(T4) + abs(T5);\n            var r_i_t: f32 = max(abs(PI * r_i / 2.0 * sin(PI * f32(t) / D - abs(T4) / PI)) * simParams.configurationCSVariables.r_i_tScaleFactor, 0.0);\n            // Melt factor\n            var vegetationDensity: f32 = 0.0;\n            var k_v: f32 = exp(-4.0 * vegetationDensity); // 1\n            var c_m: f32 = simParams.simulationCSConstants.k_m * k_v * r_i_t * (1.0 - celldata.SnowAlbedo) * dayNormalization * areaSquareMeters; // l/m^2/C�/day * day * m^2 = l/m^2 * 1/day * day * m^2 = l/C�\n            var meltFactor: f32;\n            if(tAir < simParams.simulationCSConstants.TMeltB){\n              // do something with abs of difference between A\n                meltFactor=simParams.simulationCSConstants.meltFactor * (tAir - simParams.simulationCSConstants.TMeltA + 0.01) * (tAir - simParams.simulationCSConstants.TMeltA + 0.01) / (simParams.simulationCSConstants.TMeltB - simParams.simulationCSConstants.TMeltA);\n            } else {\n                meltFactor=simParams.simulationCSConstants.meltFactor * (tAir - simParams.simulationCSConstants.TMeltA);\n            }\n\n            // Added factor to speed up melting\n            var m: f32 = c_m * meltFactor; // l/C� * C� = l \n            output_color_debug = r_i ;\n            // Apply melt\n            celldata.SnowWaterEquivalent -= m;\n        }\n    }\n    celldata.SnowWaterEquivalent = clamp(celldata.SnowWaterEquivalent, 0, simParams.configurationCSVariables.maxSWE * celldata.AreaXY);\n    var slope = degrees(celldata.Inclination);\n    var f = select((slope - (celldata.Altitude * (simParams.configurationCSVariables.areaScaleFactor / 100.0)) / 100.0) / 65.0 , 0, slope < 15.0);\n    // var f = select(slope / 70.0 , 0, slope < 15.0);\n	  var a3 = 50.0;\n\n    // celldata.InterpolatedSWE = celldata.SnowWaterEquivalent * (1 - f);\n    celldata.InterpolatedSWE = clamp(celldata.SnowWaterEquivalent * (1.1 - f) * (1 + a3 * celldata.Curvature), 0.0, simParams.configurationCSVariables.maxSWE * celldata.AreaXY);\n    // celldata.InterpolatewdSWE = celldata.SnowWaterEquivalent;\n    //celldata.Curvature-=0.001;\n    data.cells[idx] = celldata;\n    //var output_color: f32=celldata.SnowAlbedo;\n    var output_color: f32=celldata.InterpolatedSWE;\n    atomicMax(&maxSnowStorage[0],u32(output_color));\n    var debug_color_y: f32 = f32(coord.y) / f32(textureDimensions(texture2).y);\n    var debug_color_x: f32 = f32(coord.x) / f32(textureDimensions(texture2).x);\n    \n    textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(output_color,output_color,output_color,1.0));\n    // textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(output_color_debug,output_color_debug,output_color_debug,1.0));\n\n}';function getDayOfYear(e){return Math.floor(e/1e3%365)}var g=n(8175);let lerp=(e,t,n)=>(1-n)*e+n*t;var p=[0,0];async function getHeightData(e){let t=await fetch(e),n=await (0,g.mK)(await t.blob()),a=await n.getImage(),r=await a.readRasters();console.log(r);let{ModelPixelScale:i,ModelTiepoint:o}=a.fileDirectory,[s,l,u]=i,[c,m,d,f,h,x]=o;l=-l;let v=[-f/s,1/s,0,-h/l,0,1/l],P=r[0],[w,S,y,b]=a.getBoundingBox(),T=lerp(S,b,Math.random()),C=lerp(w,y,Math.random()),[A,_]=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],round=e=>a?0|e:e;return[round(n[0]+n[1]*e+n[2]*t),round(n[3]+n[4]*e+n[5]*t)]}(C,T,v,!0),{width:F,0:D}=r,M=Math.floor(F/(y-w)*(b-S));p[0]=F,p[1]=M;let B=new Float32Array(P);return B}var h=n(7160),x=n(1437),v=[0,0];async function loadAndUseHeightData(e){let t=await getHeightData(e);return v[0]=p[0],v[1]=p[1],console.log("numberarray"),console.log(p),t}async function generateTerrainMesh(e,t,n){let a=await loadAndUseHeightData(e),r=v[0],i=v[1],o=Math.floor(r/t),s=Math.floor(i/t);console.log("verticesPerRow"+o),console.log("verticesPerColumn"+s);let l=[];for(let e=0;e<s*t;e+=t)for(let s=0;s<o*t;s+=t){let t=a[e*r+s];l.push([(s-r/2)*1,t/n,(e-i/2)*1])}return{positions:l,height:s,width:o}}async function getTerrainMesh(e,t,n){return await generateTerrainMesh(e,t,n)}let normalizeAngle360=e=>(e%=360)<0?e+2*Math.PI:e;async function getTerrainCells(e){return await generateTerrainCells(e)}function getCellIndex(e,t,n,a){let r=t*n+e;return r>=0&&r<n*a&&e<n&&e>0?r:-1}async function generateTerrainCells(e){let t=e.width,n=e.height,a=(t-1)*(n-1);console.log("grid_size "+a),console.log("side_width "+(t-1)),console.log("side_height "+(n-1));let r={P0:Array(a),P1:Array(a),P2:Array(a),P3:Array(a),Aspect:Array(a),Inclination:Array(a),Altitude:Array(a),Latitude:Array(a),Area:Array(a),AreaXZ:Array(a),SnowWaterEquivalent:Array(a),InterpolatedSWE:Array(a),SnowAlbedo:Array(a),DaysSinceLastSnowfall:Array(a),Curvature:Array(a),Size:(n-1)*(t-1),MinAltitude:1/0},i=0;for(let a=0;a<n-1;a++)for(let n=0;n<t-1;n++){let o=a*(t-1)+n;r.P0[o]=e.positions[a*t+n],r.P1[o]=e.positions[a*t+n+1],r.P2[o]=e.positions[(a+1)*t+n],r.P3[o]=e.positions[(a+1)*t+n+1];let s=h.al(r.P0[o][0],r.P0[o][1],r.P0[o][2]),l=h.al(r.P1[o][0],r.P1[o][1],r.P1[o][2]),u=h.al(r.P2[o][0],r.P2[o][1],r.P2[o][2]),c=h.al(r.P3[o][0],r.P3[o][1],r.P3[o][2]),m=h.kC(h.Ue(),h.$X(h.Ue(),l,s),h.$X(h.Ue(),u,s)),d=h.al((s[0]+l[0]+u[0]+c[0])/4,(s[1]+l[1]+u[1]+c[1])/4,(s[2]+l[2]+u[2]+c[2])/4);r.Altitude[o]=d[1],r.Altitude[o]<r.MinAltitude&&(r.MinAltitude=r.Altitude[o]);let f=h.$X(h.Ue(),s,u),g=h.$X(h.Ue(),l,u),p=x.al(f[0],f[2]),v=x.al(g[0],g[2]);r.Area[o]=Math.abs(h.Zh(h.kC(h.Ue(),f,f))/2+h.Zh(h.kC(h.Ue(),g,f))/2),r.AreaXZ[o]=Math.abs(x.kC(h.Ue(),p,p)[2]/2+x.kC(h.Ue(),v,p)[2]/2);let P=h.$X(h.Ue(),c,s),w=h.al(P[0],0,P[2]);r.Inclination[o]=1e-5>h.Zh(P)?0:Math.acos(h.AK(P,w)/(h.Zh(P)*h.Zh(w))),r.Latitude[o]=47*Math.PI/180;let S=x.al(m[0],m[2]),y=x.al(0,-1),b=x.AK(S,y),T=S[0]*y[1]-S[1]*y[0];r.Aspect[o]=Math.atan2(T,b),r.Aspect[o]=normalizeAngle360(r.Aspect[o]);let C=0;if(r.Altitude[o]/100>3300){let e=r.Area[o]/1e4;i=Math.max((C=(2.5+r.Altitude[o]/100*.001)*e)/e,i)}r.SnowWaterEquivalent[o]=C}let o=t-1,s=n-1;for(let e=0;e<s;e++)for(let t=0;t<o;t++){let n=e*o+t,a=Array(8);if(a[0]=getCellIndex(t,e-1,o,s),a[1]=getCellIndex(t+1,e-1,o,s),a[2]=getCellIndex(t+1,e,o,s),a[3]=getCellIndex(t+1,e+1,o,s),a[4]=getCellIndex(t,e+1,o,s),a[5]=getCellIndex(t-1,e+1,o,s),a[6]=getCellIndex(t-1,e,o,s),a[7]=getCellIndex(t-1,e-1,o,s),-1==a[0]||-1==a[1]||-1==a[2]||-1==a[3]||-1==a[4]||-1==a[5]||-1==a[6]||-1==a[7]){r.Curvature[n]=-.0005;continue}r.Altitude[a[1]];let i=r.Altitude[a[0]]/100;r.Altitude[a[7]];let l=r.Altitude[a[2]]/100,u=r.Altitude[n]/100,c=r.Altitude[a[6]]/100;r.Altitude[a[3]];let m=r.Altitude[a[4]]/100;r.Altitude[a[5]];let d=r.P1[n][0]-r.P0[n][0],f=((l+c)/2-u)/(d*d),g=((i+m)/2-u)/(d*d);r.Curvature[n]=2*(f+g)}return r}async function generateSquareMesh(){let e={positions:[[1,0,1],[1,0,-1],[-1,0,-1],[1,0,1],[-1,0,-1],[-1,0,1]],normals:[[1],[1],[1],[0],[0],[0]],uvs:[[1,0],[1,1],[0,1],[1,0],[0,1],[0,0]]};return console.log(e),e}async function getSquareMesh(){return await generateSquareMesh()}let CameraBase=class CameraBase{get matrix(){return this.matrix_}set matrix(e){a._E.copy(e,this.matrix_)}get view(){return this.view_}set view(e){a._E.copy(e,this.view_)}get right(){return this.right_}set right(e){a.R3.copy(e,this.right_)}get up(){return this.up_}set up(e){a.R3.copy(e,this.up_)}get back(){return this.back_}set back(e){a.R3.copy(e,this.back_)}get position(){return this.position_}set position(e){a.R3.copy(e,this.position_)}constructor(){this.matrix_=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.view_=a._E.create(),this.right_=new Float32Array(this.matrix_.buffer,0,4),this.up_=new Float32Array(this.matrix_.buffer,16,4),this.back_=new Float32Array(this.matrix_.buffer,32,4),this.position_=new Float32Array(this.matrix_.buffer,48,4)}};let WASDCamera=class WASDCamera extends CameraBase{get velocity(){return this.velocity_}set velocity(e){a.R3.copy(e,this.velocity_)}get matrix(){return super.matrix}set matrix(e){super.matrix=e,this.recalculateAngles(this.back)}update(e,t){var n,r,i,o;let sign=(e,t)=>(e?1:0)-(t?1:0);this.yaw-=t.analog.x*e*this.rotationSpeed,this.pitch-=t.analog.y*e*this.rotationSpeed,this.yaw=(n=this.yaw)-Math.floor(Math.abs(n)/(r=2*Math.PI))*r*Math.sign(n),this.pitch=Math.min(Math.max(this.pitch,-Math.PI/2),Math.PI/2);let s=a.R3.copy(this.position);super.matrix=a._E.rotateX(a._E.rotationY(this.yaw),this.pitch);let l=t.digital,u=sign(l.right,l.left),c=sign(l.up,l.down),m=a.R3.create(),d=sign(l.backward,l.forward);return a.R3.addScaled(m,this.right,u,m),a.R3.addScaled(m,this.up,c,m),a.R3.addScaled(m,this.back,d,m),a.R3.normalize(m,m),a.R3.mulScalar(m,this.movementSpeed,m),this.velocity=(i=this.velocity,o=Math.pow(1-this.frictionCoefficient,e),a.R3.addScaled(m,a.R3.sub(i,m),o)),this.position=a.R3.addScaled(s,this.velocity,e),this.view=a._E.invert(this.matrix),this.view}recalculateAngles(e){this.yaw=Math.atan2(e[0],e[2]),this.pitch=-Math.asin(e[1])}constructor(e){if(super(),this.pitch=0,this.yaw=0,this.velocity_=a.R3.create(),this.movementSpeed=150,this.rotationSpeed=1,this.frictionCoefficient=.99,e&&(e.position||e.target)){var t,n;let r=null!==(t=e.position)&&void 0!==t?t:a.R3.create(0,0,-5),i=null!==(n=e.target)&&void 0!==n?n:a.R3.create(0,0,0),o=a.R3.normalize(a.R3.sub(r,i));this.recalculateAngles(o),this.position=r}}};var P=n(7048);let w={p_ww:.75,p_wd:.4,p_i_w:.6},S=(0,P.hA)(),y=n(7686),b=-1,T="",getWeatherData=(e,t,n)=>{if(""===T)var a=Math.random()<w.p_i_w?"wet":"dry";else var a=T;let r=[];for(let e=0;e<t-1;e++){r[e]=[];for(let t=0;t<n-1;t++){let n=1+S(.01*e,.01*t);r[e][t]=n}}let i={temperature:[],precipitation:[]},o=[];for(let a=0;a<t;a++){o[a]=[];for(let t=0;t<n;t++){let n=(0,P.hA)(new y(e)),r=Math.max(.9*(1+n(.01*a,.01*t))+.2,0);o[a][t]=r}}for(let s=0;s<t-1;s++)for(let l=0;l<n-1;l++){let u=0;if("wet"===a){let e=2.5*Math.exp(2.5*Math.random())/24;u=e*o[s][l]}0===s&&0===l&&s==t-2&&l==n-2&&console.log("");let c=-(9*Math.cos(2*getDayOfYear(e)*Math.PI/365))+(Math.random()-.5),m="wet"===a?-8:0,d=10+c+m+r[s][l];i.temperature[s*n+l]=d,i.precipitation[s*n+l]=u}return T="wet"===a?Math.random()<w.p_ww?"wet":"dry":"dry"===a&&Math.random()<w.p_wd?"wet":"dry",i};var C="src/sample/snowAccumulation/main.ts";let A={position:a.R3.create(-350,615,-380),target:a.R3.create(-70,550,-80)};function setCamera(e,t){let n=void 0!==e?e:A.position,a=void 0!==t?t:A.target;return new WASDCamera({position:n,target:a})}function resetTerrainBufferMapping(e,t,n){e.queue.writeBuffer(n,0,t.buffer,t.byteOffset,t.byteLength)}function getCellArray(e){let t=new Float32Array(48*e.Size/4);for(let n=0;n<e.Size;n++)t.set([e.Aspect[n],e.Inclination[n],e.Altitude[n],e.Latitude[n],e.Area[n],e.AreaXZ[n],e.SnowWaterEquivalent[n],e.InterpolatedSWE[n],e.SnowAlbedo[n],e.DaysSinceLastSnowfall[n],e.Curvature[n],0],12*n);return t}let init=async e=>{let{canvas:t,pageState:n,gui:r,stats:i}=e,o=await navigator.gpu.requestAdapter(),s=await o.requestDevice();if(!n.active)return;let l=t.getContext("webgpu");i.showPanel(0);let u=function(e,t){let n={forward:!1,backward:!1,left:!1,right:!1,up:!1,down:!1},a={x:0,y:0,zoom:0},r=!1,setDigital=(e,t)=>{switch(e.code){case"KeyW":n.forward=t,e.preventDefault(),e.stopPropagation();break;case"KeyS":n.backward=t,e.preventDefault(),e.stopPropagation();break;case"KeyA":n.left=t,e.preventDefault(),e.stopPropagation();break;case"KeyD":n.right=t,e.preventDefault(),e.stopPropagation();break;case"Space":n.up=t,e.preventDefault(),e.stopPropagation();break;case"ShiftLeft":case"ControlLeft":case"KeyC":n.down=t,e.preventDefault(),e.stopPropagation()}};return e.addEventListener("keydown",e=>setDigital(e,!0)),e.addEventListener("keyup",e=>setDigital(e,!1)),t.style.touchAction="pinch-zoom",t.addEventListener("pointerdown",()=>{r=!0}),t.addEventListener("pointerup",()=>{r=!1}),t.addEventListener("pointermove",e=>{(r="mouse"!=e.pointerType||(1&e.buttons)!=0)&&(a.x+=e.movementX,a.y+=e.movementY)}),t.addEventListener("wheel",e=>{(r=(1&e.buttons)!=0)&&(a.zoom+=Math.sign(e.deltaY),e.preventDefault(),e.stopPropagation())},{passive:!1}),()=>{let e={digital:n,analog:{x:a.x,y:a.y,zoom:a.zoom,touching:r}};return a.x=0,a.y=0,a.zoom=0,e}}(window,t),c=setCamera(),m={k2Terrain:{name:"K2",terrainFilename:"../assets/img/file/k2-h.tif",textureFilename:"../assets/img/file/k2-t.png",configurationParams:{posNormalizeFactor:5e6,posMax:150,colorMaxScaleFactor:.64,areaScaleFactor:100,r_i_tScaleFactor:.82,k_mScaleFactor:2.5,meltFactor:5.5,maxSWE:6e5,temperatureLapseNormalizeFactor:20,precipitationLapseNormalizeFactor:20,heightMul:.104,gridSize:.7,terrainSkip:3,terrainDataNormalizeFactor:10,defaultTemperature:8},cameraDefaults:{position:a.R3.create(-70,350,-80),target:a.R3.create(-800,400,-1e3)}},everestTerrain:{name:"Everest",terrainFilename:"../assets/img/file/everest.tif",textureFilename:"../assets/img/file/rock.png",configurationParams:{posNormalizeFactor:5e6,posMax:175,colorMaxScaleFactor:.7,areaScaleFactor:500,r_i_tScaleFactor:.78,k_mScaleFactor:2.5,meltFactor:5.5,maxSWE:2e6,temperatureLapseNormalizeFactor:7,precipitationLapseNormalizeFactor:7.5,heightMul:.07,gridSize:4.57,terrainSkip:1,terrainDataNormalizeFactor:100,defaultTemperature:-1.7},cameraDefaults:{position:a.R3.create(-350,615,-380),target:a.R3.create(-70,550,-80)}}},g={terrain:m.everestTerrain},h={resetCamera(){c=setCamera(g.terrain.cameraDefaults.position,g.terrain.cameraDefaults.target)}},x={guiTemperature:g.terrain.configurationParams.defaultTemperature,guiPrecipitation:0,useGuiWeather:!0},v={showStats:!0,showMemoryUsage:!1},P={measurementAltitude:0,tSnowA:0,tSnowB:2,tMeltA:-5,tMeltB:-2,k_e:.2,k_m:g.terrain.configurationParams.k_mScaleFactor,meltFactor:g.terrain.configurationParams.meltFactor,timesteps:0,currentSimulationStep:0,hourOfDay:12,dayOfYear:251},w={heightMul:g.terrain.configurationParams.heightMul,gridSize:g.terrain.configurationParams.gridSize},S={fogStartDist:30,fogEndDist:1200};var y=r.addFolder("Reset");y.open(),y.add(h,"resetCamera").name("Reset Camera");var b=r.addFolder("Terrain");b.open();var T=r.addFolder("Weather");T.open();let C=T.add(x,"guiTemperature",-10,30).name("Temperature"),A=T.add(x,"guiPrecipitation",0,1.5).name("Precipitation").step(.01);T.add(x,"useGuiWeather").name("Use Gui Weather");var _=r.addFolder("Stats");_.add(v,"showStats").name("Show Stats"),_.add(v,"showMemoryUsage").name("Memory Usage");var F=r.addFolder("Simulation Constants");F.add(P,"measurementAltitude",0,1e4).name("Measurement Altitude"),F.add(P,"tSnowA",-5,5).name("Temp Snow A").step(.5),F.add(P,"tSnowB",-5,5).name("Temp Snow B").step(.5),F.add(P,"tMeltA",-10,5).name("Temp Melt A").step(.5),F.add(P,"tMeltB",-10,5).name("Temp Melt B").step(.5),F.add(P,"k_e",0,1).name("k_e").step(.1),F.add(P,"k_m",0,10).name("k_m").step(.5),F.add(P,"meltFactor",0,10).name("Melt Factor").step(.1),F.add(P,"timesteps",0,100).name("Timesteps").step(1),F.add(P,"currentSimulationStep",0,100).name("Curr Step").step(1),F.add(P,"hourOfDay",0,24).name("Hour of Day").step(.5),F.add(P,"dayOfYear",0,365).name("Day of Year").step(1);var D=r.addFolder("Size");D.open(),D.add(w,"heightMul",0,.2).name("Height Multiplier").step(.002),D.add(w,"gridSize",0,10).name("Grid Size").step(.01);var M=r.addFolder("Fog");M.open(),M.add(S,"fogStartDist",10,100).name("Fog Start"),M.add(S,"fogEndDist",1e3,5e3).name("Fog End");let B=window.devicePixelRatio;t.width=t.clientWidth*B,t.height=t.clientHeight*B;let E=navigator.gpu.getPreferredCanvasFormat(),U=await createSkyboxPipeline(s,E);console.log("binding for skybox vertex buffer");let z=s.createBuffer({size:d.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(z.getMappedRange()).set(d),z.unmap(),console.log("done for binding for skybox vertex buffer");let I=s.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),R=await loadCubemapTexture(s),G=s.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}),L=s.createBindGroup({layout:U.getBindGroupLayout(0),label:"skybox group",entries:[{binding:0,resource:{buffer:I,size:64}},{binding:1,resource:G},{binding:2,resource:R.createView({dimension:"cube"})}]});console.log(L),l.configure({device:s,format:E,alphaMode:"premultiplied"}),s.createBuffer({size:0,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE});let k=await getTerrainMesh(g.terrain.terrainFilename,g.terrain.configurationParams.terrainSkip,g.terrain.configurationParams.terrainDataNormalizeFactor),N=await getSquareMesh(),V=await getTerrainCells(k);console.log(V.Size);let O=[11*k.width+6,11*k.width+7,9*k.width+15,9*k.width+16,9*k.width+17,9*k.width+18,110*k.height+60,11*k.height+7,9*k.height+15,9*k.height+16,9*k.height+17,9*k.height+18,30851,30852,30853];for(let e=0;e<O.length;e++){let t=O[e];console.log("Inclination:  "+V.Inclination[t]),console.log("Altitude:  "+V.Altitude[t]),console.log("AreaXZ:  "+100*V.AreaXZ[t])}async function setCellBuffer(e){let t=s.createBuffer({size:48*e.Size,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});{let n=new Float32Array(t.getMappedRange());for(let t=0;t<e.Size;t++)n.set([e.Aspect[t],e.Inclination[t],e.Altitude[t],e.Latitude[t],e.Area[t],e.AreaXZ[t],e.SnowWaterEquivalent[t],e.InterpolatedSWE[t],e.SnowAlbedo[t],e.DaysSinceLastSnowfall[t],e.Curvature[t],0],12*t);t.unmap()}return t}let W=await setCellBuffer(V),q=getCellArray(V);h.resetSimulation=function(){x.guiPrecipitation=0,x.guiTemperature=g.terrain.configurationParams.defaultTemperature,A.updateDisplay(),C.updateDisplay(),resetTerrainBufferMapping(s,q,W)},y.add(h,"resetSimulation").name("Reset Simulation");let Y=s.createBuffer({size:16,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),X=s.createBuffer({label:"vertex buffer",size:6*N.positions.length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});{let e=new Float32Array(X.getMappedRange());for(let t=0;t<N.positions.length;++t)e.set(N.positions[t],6*t),e.set(N.normals[t],6*t+3),e.set(N.uvs[t],6*t+4);X.unmap()}let H=[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:2,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]}],j=s.createRenderPipeline({layout:"auto",vertex:{module:s.createShaderModule({code:f}),entryPoint:"vs_main",buffers:H},fragment:{module:s.createShaderModule({code:f}),entryPoint:"fs_main",targets:[{format:E}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),Z=s.createTexture({size:[t.width,t.height],format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT}),K=s.createTexture({size:[k.width-1,k.height-1,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});console.log("writableTexture width: "+(k.width-1)+" height: "+(k.height-1));let $=s.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});async function setColorTexture(e){let t=await fetch(e),n=await createImageBitmap(await t.blob());return{texture:s.createTexture({size:[n.width,n.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),image:n}}async function setHeightTexture(e){let t=await getHeightData(e);return console.log("heightdata test"),console.log("heightData: "+t[0]),{texture:s.createTexture({size:[p[0],p[1],1],format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),data:t}}let J=await setColorTexture(g.terrain.textureFilename);s.queue.copyExternalImageToTexture({source:J.image},{texture:J.texture},[J.image.width,J.image.height]);let Q=await setHeightTexture(g.terrain.terrainFilename);s.queue.writeTexture({texture:Q.texture},Q.data,{bytesPerRow:4*p[0]},{width:p[0],height:p[1]});let ee=!1,et=!1;b.add(g,"terrain",Object.values(m).map(e=>e.name)).name("Select Terrain").setValue(m.everestTerrain.name).onChange(async function(e){var t;g.terrain=Object.values(m).find(t=>t.name===e),k=await getTerrainMesh(g.terrain.terrainFilename,g.terrain.configurationParams.terrainSkip,g.terrain.configurationParams.terrainDataNormalizeFactor),V=await getTerrainCells(k),Q=await setHeightTexture(g.terrain.terrainFilename),J=await setColorTexture(g.terrain.textureFilename),q=getCellArray(V),W=await setCellBuffer(V),t=k,K=s.createTexture({size:[t.width-1,t.height-1,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let e=0;e<O.length;e++){let t=O[e];console.log("Inclination:  "+V.Inclination[t]),console.log("Altitude:  "+V.Altitude[t]),console.log("AreaXZ:  "+V.AreaXZ[t])}console.log("cellBuffer.size: "+W.size),w.heightMul=g.terrain.configurationParams.heightMul,w.gridSize=g.terrain.configurationParams.gridSize,D.updateDisplay(),P.k_m=g.terrain.configurationParams.k_mScaleFactor,P.meltFactor=g.terrain.configurationParams.meltFactor,F.updateDisplay(),x.guiTemperature=g.terrain.configurationParams.defaultTemperature,T.updateDisplay(),h.resetSimulation(),c=setCamera(g.terrain.cameraDefaults.position,g.terrain.cameraDefaults.target),et=!0,ee=!0}),g.terrain=m.everestTerrain,console.log("amount of mesh:"+(Q.texture.width-1)*(Q.texture.height-1));let en=new Float32Array([.1,.1]),ea=s.createBuffer({label:"Grid Uniforms",size:en.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});s.queue.writeBuffer(ea,0,en);let er=s.createBindGroup({layout:j.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}},{binding:1,resource:K.createView()},{binding:2,resource:J.texture.createView()},{binding:3,resource:{buffer:ea}},{binding:4,resource:Q.texture.createView()},{binding:5,resource:{buffer:Y}}]}),ei={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:Z.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},eo=s.createBuffer({size:96,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),es=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:f}),entryPoint:"simulate"}}),el=s.createBindGroup({layout:es.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:eo}},{binding:1,resource:{buffer:W,offset:0,size:48*V.Size}},{binding:2,resource:J.texture.createView()},{binding:3,resource:K.createView({format:"rgba32float",dimension:"2d"})},{binding:4,resource:{buffer:Y}}]}),eu=t.width/t.height,ec=a._E.perspective(2*Math.PI/5,eu,1,100),em=a._E.create(),ed=a._E.create(),ef=a._E.perspective(2*Math.PI/5,eu,1,15e3),eg=a._E.create(),ep=Date.now(),eh=Date.now(),ex=getWeatherData(ep,2,2);requestAnimationFrame(function frame(){if(!n.active)return;let e=Date.now(),t=(e-ep)/1e3,r=e-eh;ep=e,v.showStats?v.showMemoryUsage?i.showPanel(2):i.showPanel(0):i.showPanel(3);let o=c.update(t,u()),m=a._E.clone(o);m[12]=0,m[13]=0,m[14]=0,Math.floor(r/1e3)>=1&&!x.useGuiWeather&&(console.log("day of year: "+getDayOfYear(e)),eh=e,console.log("weatherData: "+(ex=getWeatherData(e,k.width,k.height)).temperature[0]+" : "+ex.precipitation[0])),ee&&(s.queue.writeTexture({texture:Q.texture},Q.data,{bytesPerRow:4*p[0]},{width:p[0],height:p[1]}),er=s.createBindGroup({layout:j.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}},{binding:1,resource:K.createView()},{binding:2,resource:J.texture.createView()},{binding:3,resource:{buffer:ea}},{binding:4,resource:Q.texture.createView()},{binding:5,resource:{buffer:Y}}]}),el=s.createBindGroup({layout:es.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:eo}},{binding:1,resource:{buffer:W,offset:0,size:48*V.Size}},{binding:2,resource:J.texture.createView()},{binding:3,resource:K.createView({format:"rgba32float",dimension:"2d"})},{binding:4,resource:{buffer:Y}}]}),resetTerrainBufferMapping(s,q,W),ee=!1),et&&(s.queue.copyExternalImageToTexture({source:J.image},{texture:J.texture},[J.image.width,J.image.height]),er=s.createBindGroup({layout:j.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}},{binding:1,resource:K.createView()},{binding:2,resource:J.texture.createView()},{binding:3,resource:{buffer:ea}},{binding:4,resource:Q.texture.createView()},{binding:5,resource:{buffer:Y}}]}),et=!1),s.queue.writeBuffer(eo,0,new Float32Array([V.MinAltitude,P.tSnowA,P.tSnowB,P.tMeltA,P.tMeltB,P.k_e,P.k_m,P.meltFactor,P.timesteps,P.currentSimulationStep,P.hourOfDay,P.dayOfYear,g.terrain.configurationParams.posNormalizeFactor,g.terrain.configurationParams.posMax,g.terrain.configurationParams.colorMaxScaleFactor,g.terrain.configurationParams.areaScaleFactor,g.terrain.configurationParams.r_i_tScaleFactor,g.terrain.configurationParams.maxSWE,g.terrain.configurationParams.temperatureLapseNormalizeFactor,g.terrain.configurationParams.precipitationLapseNormalizeFactor,x.useGuiWeather?x.guiTemperature:ex.temperature[0],x.useGuiWeather?x.guiPrecipitation:ex.precipitation[0],0,0])),a._E.identity(em),a._E.translate(em,a.R3.fromValues(0,0,-3),em),a._E.rotateX(em,-.2*Math.PI,em),a._E.multiply(ec,em,ed);let d=function(e){let t=c.update(e,u());return a._E.multiply(ef,t,eg),eg}(t);s.queue.writeBuffer($,0,d.buffer,d.byteOffset,d.byteLength),s.queue.writeBuffer($,64,new Float32Array([c.position[0],c.position[1],c.position[2],S.fogStartDist,em[5],em[9],S.fogEndDist,w.heightMul,g.terrain.configurationParams.posNormalizeFactor,g.terrain.configurationParams.posMax,g.terrain.configurationParams.colorMaxScaleFactor,g.terrain.configurationParams.areaScaleFactor,g.terrain.configurationParams.r_i_tScaleFactor,g.terrain.configurationParams.maxSWE,g.terrain.configurationParams.temperatureLapseNormalizeFactor,g.terrain.configurationParams.precipitationLapseNormalizeFactor])),s.queue.writeBuffer(ea,0,new Float32Array([w.gridSize,w.gridSize]));let f=new Uint32Array([0,0,0,0]);s.queue.writeBuffer(Y,0,f.buffer,f.byteOffset,f.byteLength);let h=l.getCurrentTexture();ei.colorAttachments[0].view=h.createView(),v.showStats&&i.begin();let y=s.createCommandEncoder();{let e=y.beginComputePass();e.setPipeline(es),e.setBindGroup(0,el),e.dispatchWorkgroups(Math.ceil((k.width-1)/8),Math.ceil((k.height-1)/8)),e.end()}{let e=y.beginRenderPass(ei);e.setPipeline(j),e.setBindGroup(0,er),e.setVertexBuffer(0,X),e.draw(6,(Q.texture.width-1)*(Q.texture.height-1)),renderSkybox(s,U,z,I,L,e,d),e.end()}s.queue.submit([y.finish()]),requestAnimationFrame(frame),v.showStats&&i.end()})};var main=()=>makeSample({name:"snowAccmulation",description:"This is real-time snow accumulation on terrein based on real data",gui:!0,stats:!0,init,sources:[{name:C.substring(28),contents:'import { mat4, vec3 } from \'wgpu-matrix\';\nimport { makeSample, SampleInit } from \'../../components/SampleLayout\';\nimport { renderSkybox } from \'./skyboxPipeline\';\nimport { cubeVertexArray, cubeVertexSize, cubeUVOffset, cubePositionOffset, cubeVertexCount } from \'../../meshes/cube\';\nimport { createSkyboxPipeline, loadCubemapTexture } from \'./skyboxPipeline\';\n\n\nimport particleWGSL from \'./particle.wgsl\';\nimport { getTerrainMesh, getTerrainCells } from \'../../meshes/terrain\';\nimport { getSquareMesh} from \'../../meshes/square\';\nimport { WASDCamera, cameraSourceInfo } from \'./camera\';\nimport { createInputHandler, inputSourceInfo } from \'./input\';\nimport { getWeatherData } from \'./weather\';\nimport { getDayOfYear, getHourOfDay,degreesToRadians, timeToDays, timeToHours, getNumHoursPassed, getNumDaysPassed, getMin} from \'../../meshes/utils\';\nimport { computeSnowCPU } from \'./snowCompute\';\nimport { max, set } from \'wgpu-matrix/dist/2.x/vec2-impl\';\nimport { getHeightData, numberArray } from \'../../meshes/geotiff-utils\';\n\nconst numParticles = 0;\nconst particlePositionOffset = 0;\nconst particleColorOffset = 4 * 4;\nconst particleInstanceByteSize =\n  3 * 4 + // position\n  1 * 4 + // lifetime\n  4 * 4 + // color\n  3 * 4 + // velocity\n  1 * 4 + // padding\n  0;\n\nconst cellInstanceByteSize =\n  11 * 4 + // data\n  1 * 4 + // padding\n  0;\n\nconst cameraDefaults = {\n  position: vec3.create(-350, 615, -380),\n  target: vec3.create(-70, 550, -80),\n};\n\n\nfunction setCamera(position?, target?)\n{\n  const initialCameraPosition = typeof position !== \'undefined\' ? position : cameraDefaults.position;\n  const initialCameraTarget = typeof target !== \'undefined\' ? target : cameraDefaults.target;\n  return new WASDCamera({ position: initialCameraPosition, target: initialCameraTarget });\n}\n\nfunction resetTerrainBufferMapping(device, cellArray, cellBuffer)\n{\n  device.queue.writeBuffer(\n    cellBuffer,\n    0,\n    cellArray.buffer,\n    cellArray.byteOffset,\n    cellArray.byteLength\n  );\n}\n\n  \nfunction getCellArray(terrainCells)\n{\n  const cellArray = new Float32Array(terrainCells.Size * cellInstanceByteSize / 4);\n  for (let i = 0; i < terrainCells.Size; i++){\n    cellArray.set([\n      terrainCells.Aspect[i],\n      terrainCells.Inclination[i],\n      terrainCells.Altitude[i],\n      terrainCells.Latitude[i],\n      terrainCells.Area[i],\n      terrainCells.AreaXZ[i],\n      terrainCells.SnowWaterEquivalent[i],\n      terrainCells.InterpolatedSWE[i],\n      terrainCells.SnowAlbedo[i],\n      terrainCells.DaysSinceLastSnowfall[i],\n      terrainCells.Curvature[i],\n      0.0,\n    ],i*12);\n  }\n  return cellArray;\n}\n\nconst init: SampleInit = async ({ canvas, pageState, gui, stats }) => {\n \n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n\n  if (!pageState.active) return;\n  const context = canvas.getContext(\'webgpu\') as GPUCanvasContext;\n  stats.showPanel(0);\n \n  // The input handler\n  const inputHandler = createInputHandler(window, canvas);\n\n  // Camera initialization\n  let camera = setCamera();\n  let guiPrecipitation = 0.0;\n\n\n\n  const terrainOptions = {\n    k2Terrain: {\n      name: "K2",\n      terrainFilename: "../assets/img/file/k2-h.tif",\n      textureFilename: "../assets/img/file/k2-t.png",\n      configurationParams: {\n        posNormalizeFactor: 5000000.0, //done\n        posMax: 150.0, //done\n        colorMaxScaleFactor: 0.64, //done\n        areaScaleFactor: 100.0, //done\n        r_i_tScaleFactor: 0.82, //done\n        k_mScaleFactor: 2.5, //done\n        meltFactor: 5.5, //done\n        maxSWE: 600000.0, //done\n        temperatureLapseNormalizeFactor: 20.0, //done\n        precipitationLapseNormalizeFactor: 20.0, //done\n        heightMul: 0.104, //done\n        gridSize: 0.7, //done\n        terrainSkip: 3, //done\n        terrainDataNormalizeFactor: 10.0, //done\n        defaultTemperature: 8.0, //done\n      },\n      cameraDefaults: {\n        position: vec3.create(-70, 350, -80),\n        target: vec3.create(-800, 400, -1000),\n      }\n    },\n    everestTerrain: {\n      name: "Everest",\n      terrainFilename: "../assets/img/file/everest.tif",\n      textureFilename: "../assets/img/file/rock.png",\n      configurationParams: {\n        posNormalizeFactor: 5000000.0,\n        posMax: 175.0,\n        colorMaxScaleFactor: 0.70,\n        areaScaleFactor: 500.0,\n        r_i_tScaleFactor: 0.78,\n        k_mScaleFactor: 2.5,\n        meltFactor: 5.5,\n        maxSWE: 2000000.0,\n        temperatureLapseNormalizeFactor: 7.0,\n        precipitationLapseNormalizeFactor: 7.5,\n        heightMul: 0.07, \n        gridSize: 4.57, \n        terrainSkip: 1.0,\n        terrainDataNormalizeFactor: 100.0,\n        defaultTemperature: -1.7,\n      },\n      cameraDefaults: {\n        position: vec3.create(-350, 615, -380),\n        target: vec3.create(-70, 550, -80),\n      }\n    },\n  };\n\n  const terrainParams = {\n    terrain: terrainOptions.everestTerrain,\n  }\n\n  const resetParams: any = \n  {\n    resetCamera() {\n      camera = setCamera(terrainParams.terrain.cameraDefaults.position, terrainParams.terrain.cameraDefaults.target);\n    },\n  };\n\n  const weatherParams = \n  {\n    guiTemperature: terrainParams.terrain.configurationParams.defaultTemperature,\n    guiPrecipitation: guiPrecipitation,\n    useGuiWeather: true,\n  }\n\n  const statsParams =\n  {\n    showStats: true,\n    showMemoryUsage: false,\n  }\n\n  const constantsParams = \n  {\n    measurementAltitude: 0.0,\n    tSnowA: 0.0,\n    tSnowB: 2.0,\n    tMeltA: -5.0,\n    tMeltB: -2.0,\n    k_e: 0.2,\n    k_m: terrainParams.terrain.configurationParams.k_mScaleFactor,\n    meltFactor: terrainParams.terrain.configurationParams.meltFactor,\n    timesteps: 0.0,\n    currentSimulationStep: 0.0,\n    hourOfDay: 12.0,\n    dayOfYear: 251.0, // TODO: pre-defined weather values for a year simulation\n  }\n\n  const sizeParams = \n  {\n    heightMul: terrainParams.terrain.configurationParams.heightMul,\n    gridSize: terrainParams.terrain.configurationParams.gridSize,\n  }\n\n  const fogParams = \n  {\n    fogStartDist: 30.0,\n    fogEndDist: 1200.0,\n  }\n\n\n\n  var resetFolder = gui.addFolder(\'Reset\');\n  resetFolder.open();\n  resetFolder.add(resetParams, \'resetCamera\').name("Reset Camera");\n\n  var terrainFolder = gui.addFolder(\'Terrain\');\n  terrainFolder.open();\n\n\n  var weatherFolder = gui.addFolder(\'Weather\');\n  weatherFolder.open();\n  let temperatureController = weatherFolder.add(weatherParams, \'guiTemperature\', -10.0, 30.0).name("Temperature");\n  let precipController = weatherFolder.add(weatherParams, \'guiPrecipitation\', 0.0, 1.5).name("Precipitation").step(0.01);\n  weatherFolder.add(weatherParams, \'useGuiWeather\').name("Use Gui Weather");\n  // precipController = precipController.step(0.1);\n\n  var statsFolder = gui.addFolder(\'Stats\');\n  // statsFolder.open();\n  statsFolder.add(statsParams, \'showStats\').name("Show Stats");\n  statsFolder.add(statsParams, \'showMemoryUsage\').name("Memory Usage");\n\n  var constantsFolder = gui.addFolder(\'Simulation Constants\');\n  // constantsFolder.open();\n  constantsFolder.add(constantsParams, \'measurementAltitude\', 0.0, 10000.0).name("Measurement Altitude");\n  constantsFolder.add(constantsParams, \'tSnowA\', -5.0, 5.0).name("Temp Snow A").step(0.5);\n  constantsFolder.add(constantsParams, \'tSnowB\', -5.0, 5.0).name("Temp Snow B").step(0.5);\n  constantsFolder.add(constantsParams, \'tMeltA\', -10.0, 5.0).name("Temp Melt A").step(0.5);\n  constantsFolder.add(constantsParams, \'tMeltB\', -10.0, 5.0).name("Temp Melt B").step(0.5);\n  constantsFolder.add(constantsParams, \'k_e\', 0.0, 1.0).name("k_e").step(0.1);\n  constantsFolder.add(constantsParams, \'k_m\', 0.0, 10.0).name("k_m").step(0.5);\n  constantsFolder.add(constantsParams, \'meltFactor\', 0.0, 10.0).name("Melt Factor").step(0.1);\n  constantsFolder.add(constantsParams, \'timesteps\', 0.0, 100.0).name("Timesteps").step(1.0);\n  constantsFolder.add(constantsParams, \'currentSimulationStep\', 0.0, 100.0).name("Curr Step").step(1.0);\n  constantsFolder.add(constantsParams, \'hourOfDay\', 0.0, 24.0).name("Hour of Day").step(0.5);\n  constantsFolder.add(constantsParams, \'dayOfYear\', 0.0, 365.0).name("Day of Year").step(1.0);\n\n  var sizeFolder = gui.addFolder(\'Size\');\n  sizeFolder.open();\n  sizeFolder.add(sizeParams, \'heightMul\', 0.0, 0.2).name("Height Multiplier").step(0.002);\n  sizeFolder.add(sizeParams, \'gridSize\', 0.0, 10.0).name("Grid Size").step(0.01);\n \n  var fogFolder = gui.addFolder(\'Fog\');\n  fogFolder.open();\n  fogFolder.add(fogParams, \'fogStartDist\', 10.0, 100.0).name("Fog Start");\n  fogFolder.add(fogParams, \'fogEndDist\', 1000.0, 5000.0).name("Fog End"); \n\n  const devicePixelRatio = window.devicePixelRatio;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n  \n  // Setup skybox pipeline here\n  //skyboxPipeline = await createSkyboxPipeline(device, presentationFormat);\n  // Initialize the skybox pipeline\n  //const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\n  \n    // Initialize the skybox pipeline\n    const skyboxPipeline = await createSkyboxPipeline(device, presentationFormat);\n\n    // Initialize the vertex buffer for the skybox\n    console.log("binding for skybox vertex buffer");\n    const skyboxVerticesBuffer = device.createBuffer({\n      size: cubeVertexArray.byteLength,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Float32Array(skyboxVerticesBuffer.getMappedRange()).set(cubeVertexArray);\n    skyboxVerticesBuffer.unmap();\n    console.log("done for binding for skybox vertex buffer");\n    // Initialize the uniform buffer for the skybox\n    const skyboxUniformBuffer = device.createBuffer({\n      size: 16 * 4,  // Size for 2 4x4 matrices (view and projection)\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n  \n    // Load the cubemap texture for the skybox\n    const cubemapTexture = await loadCubemapTexture(device);\n  \n    // Create a sampler for the cubemap texture\n    const cubemapSampler = device.createSampler({\n      magFilter: \'linear\',\n      minFilter: \'linear\',\n      mipmapFilter: \'linear\',\n      addressModeU: \'clamp-to-edge\',\n      addressModeV: \'clamp-to-edge\',\n      addressModeW: \'clamp-to-edge\',\n    });\n  \n    // Initialize the uniform bind group for the skybox\n    const skyboxUniformBindGroup = device.createBindGroup({\n      layout: skyboxPipeline.getBindGroupLayout(0),\n      label: "skybox group",\n      entries: [\n        { binding: 0, resource: { buffer: skyboxUniformBuffer,size: 4*16,} },\n        { binding: 1, resource: cubemapSampler },\n        { binding: 2, resource: cubemapTexture.createView({\n          dimension: \'cube\',\n        }) },\n      ],\n    });\n    console.log(skyboxUniformBindGroup);\n  \n  context.configure({\n    device,\n    format: presentationFormat,\n    alphaMode: \'premultiplied\',\n  });\n\n  const particlesBuffer = device.createBuffer({\n    size: numParticles * particleInstanceByteSize,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,\n  });\n\n  \n\n  let mesh=await getTerrainMesh(terrainParams.terrain.terrainFilename, terrainParams.terrain.configurationParams.terrainSkip, terrainParams.terrain.configurationParams.terrainDataNormalizeFactor);\n  const smesh=await getSquareMesh();\n  let terrainCells = await getTerrainCells(mesh);\n  console.log(terrainCells.Size);\n\n\n  // TODO: replace with a value in terrain mesh itself\n  // const minAltitude = getMin(terrainCells.Altitude);\n\n  const terrainCellsDebugIndex = [11 * mesh.width + 6, 11 * mesh.width + 7, 9 * mesh.width + 15,\n                                  9 * mesh.width + 16, 9 * mesh.width + 17, 9 * mesh.width + 18,\n                                  110 * mesh.height + 60, 11 * mesh.height + 7, 9 * mesh.height + 15,\n                                  9 * mesh.height + 16, 9 * mesh.height + 17, 9 * mesh.height + 18,\n                                  30851, 30852, 30853]\n\n  // // for (let i = 0; i < 580; i += 20) {\n  for (let i = 0; i < terrainCellsDebugIndex.length; i++) {\n    const currIndex = terrainCellsDebugIndex[i];\n  //   console.log("Terrain Cell: " + currIndex)\n  //   console.log("P0: " + " " + terrainCells.P0[currIndex]);\n  //   console.log("P1: " + " " + terrainCells.P1[currIndex]);\n  //   console.log("P2: " + " " + terrainCells.P2[currIndex]);\n  //   console.log("P3: " + " " + terrainCells.P3[currIndex]);\n  //   console.log("Aspect: " + " " + terrainCells.Aspect[currIndex]);\n    console.log("Inclination: " + " " + terrainCells.Inclination[currIndex]);\n    console.log("Altitude: " + " " + terrainCells.Altitude[currIndex]);\n  //   // console.log("Latitude: " + i + " " + terrainCells.Latitude[i]);\n  //   console.log("Area: " + " " + terrainCells.Area[currIndex]);\n    console.log("AreaXZ: " + " " + terrainCells.AreaXZ[currIndex] * 100);\n  //   // console.log("SnowWaterEquivalent: " + i + " " + terrainCells.SnowWaterEquivalent[i]);\n  //   // console.log("InterpolatedSWE: " + i + " " + terrainCells.InterpolatedSWE[i]);\n  //   // console.log("SnowAlbedo: " + i + " " + terrainCells.SnowAlbedo[i]);\n  //   // console.log("DaysSinceLastSnowfall: " + i + " " + terrainCells.DaysSinceLastSnowfall[i]);\n  //   console.log("Curvature: " + " " + terrainCells.Curvature[currIndex]);\n  // // }\n  }\n\n  async function setCellBuffer(terrainCells)\n  {\n    let cellBuffer = device.createBuffer({\n      size: terrainCells.Size * cellInstanceByteSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    {\n      const mapping = new Float32Array(cellBuffer.getMappedRange());\n      for (let i = 0; i < terrainCells.Size; i++){\n        mapping.set([\n          terrainCells.Aspect[i],\n          terrainCells.Inclination[i],\n          terrainCells.Altitude[i],\n          terrainCells.Latitude[i],\n          terrainCells.Area[i],\n          terrainCells.AreaXZ[i],\n          terrainCells.SnowWaterEquivalent[i],\n          terrainCells.InterpolatedSWE[i],\n          terrainCells.SnowAlbedo[i],\n          terrainCells.DaysSinceLastSnowfall[i],\n          terrainCells.Curvature[i],\n          0.0,\n        ],i*12);\n      }\n      cellBuffer.unmap();\n    }\n    return cellBuffer;\n  }\n\n  let cellBuffer = await setCellBuffer(terrainCells);\n  let cellArray = getCellArray(terrainCells);\n\n\n  resetParams.resetSimulation = function() {\n    weatherParams.guiPrecipitation = 0.0;\n    weatherParams.guiTemperature = terrainParams.terrain.configurationParams.defaultTemperature;\n    precipController.updateDisplay();\n    temperatureController.updateDisplay();\n    resetTerrainBufferMapping(device, cellArray, cellBuffer);\n  };\n  resetFolder.add(resetParams, \'resetSimulation\').name("Reset Simulation");\n\n  const maxBuffer = device.createBuffer({\n    size: 4 * 4,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n  });\n  \n  \n  /*const indexCount = smesh.triangles.length * 3;\n  console.log("buffer size"+indexCount * Uint16Array.BYTES_PER_ELEMENT);\n  console.log("mesh.triangles.length: " + smesh.triangles.length)*/\n  /*const indexBuffer = device.createBuffer({\n    label: "index buffer",\n    size: indexCount * Uint16Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.INDEX,\n    mappedAtCreation: true,\n  });\n  {\n    const mapping = new Uint16Array(indexBuffer.getMappedRange());\n    for (let i = 0; i < smesh.triangles.length; ++i) {\n      mapping.set(smesh.triangles[i], 3 * i);\n    }\n    indexBuffer.unmap();\n  }*/\n  const vertexBuffer = device.createBuffer({\n    label: "vertex buffer",\n    size: smesh.positions.length * 6 * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  \n  {\n    const mapping = new Float32Array(vertexBuffer.getMappedRange());\n    for (let i = 0; i < smesh.positions.length; ++i) {\n      mapping.set(smesh.positions[i], 6 * i);\n      mapping.set(smesh.normals[i], 6 * i + 3);\n      mapping.set(smesh.uvs[i], 6 * i+4);\n    }\n    vertexBuffer.unmap();\n  }\n  const vertexBuffers: Iterable<GPUVertexBufferLayout> = [\n    {\n      arrayStride: Float32Array.BYTES_PER_ELEMENT * 6,\n      attributes: [\n        {\n          // position\n          shaderLocation: 0,\n          offset: 0,\n          format: \'float32x3\',\n        },\n        {\n          // normal\n          shaderLocation: 1,\n          offset: Float32Array.BYTES_PER_ELEMENT * 3,\n          format: \'float32\',\n        },\n        {\n          // uv\n          shaderLocation: 2,\n          offset: Float32Array.BYTES_PER_ELEMENT * 4,\n          format: \'float32x2\',\n        },\n      ],\n    },\n  ];\n\n  const renderPipeline = device.createRenderPipeline({\n    layout: \'auto\',\n    vertex: {\n      module: device.createShaderModule({\n        code: particleWGSL,\n      }),\n      entryPoint: \'vs_main\',\n      buffers: vertexBuffers,\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: particleWGSL,\n      }),\n      entryPoint: \'fs_main\',\n      targets: [\n        {\n          format: presentationFormat,\n        },\n      ],\n    },\n    primitive: {\n      topology: \'triangle-list\',\n    },\n\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: \'less\',\n      format: \'depth24plus-stencil8\',\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: [canvas.width, canvas.height],\n    format: \'depth24plus-stencil8\',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  let writableTexture = device.createTexture({\n    size: [mesh.width-1, mesh.height-1, 1],\n    format: \'rgba32float\', // Adjust based on your requirements\n    usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  console.log("writableTexture width: " + (mesh.width - 1) + " height: " + (mesh.height - 1));\n  const uniformBufferSize =\n    4 * 4 * 4 + // modelViewProjectionMatrix : mat4x4<f32>\n    3 * 4 + // right : vec3<f32>\n    4 + // padding\n    3 * 4 + // up : vec3<f32>\n    4 + // heightMul\n    8 * 4 + //configurationCS\n    0;\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n\n\n  // let cubeTexture: GPUTexture;\n  // {\n  //   const response = await fetch(\'../assets/img/file/k2-t.png\');\n  //   // const response = await fetch(\'../assets/img/Di-3d.png\');\n  //   const imageBitmap = await createImageBitmap(await response.blob());\n\n  //   cubeTexture = device.createTexture({\n  //     size: [imageBitmap.width, imageBitmap.height, 1],\n  //     format: \'rgba8unorm\',\n  //     usage:\n  //       GPUTextureUsage.TEXTURE_BINDING |\n  //       GPUTextureUsage.COPY_DST |\n  //       GPUTextureUsage.RENDER_ATTACHMENT,\n  //   });\n  //   device.queue.copyExternalImageToTexture(\n  //     { source: imageBitmap },\n  //     { texture: cubeTexture },\n  //     [imageBitmap.width, imageBitmap.height]\n  //   );\n  // }\n  /*let heightTexture: GPUTexture;\n  {\n    const response = await fetch(\'../assets/img/file/height1.png\');\n    //const response = await fetch(\'../assets/img/Di-3d.png\');\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    heightTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: \'rgba8unorm\',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: imageBitmap },\n      { texture: heightTexture },\n      [imageBitmap.width, imageBitmap.height]\n    );\n  }*/\n  async function setColorTexture(filename)\n  {\n    const response = await fetch(filename);\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    let cubeTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: \'rgba8unorm\',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    return { texture: cubeTexture, image: imageBitmap };\n  }\n\n  async function setHeightTexture(filename)\n  {\n    // const url = \'../assets/img/file/k2-h.tif\';\n    const heightData = await getHeightData(filename);\n    \n    console.log("heightdata test");\n    console.log("heightData: " + heightData[0]);\n\n    let heightTextureSet = device.createTexture({\n      size: [numberArray[0], numberArray[1],1],\n      format: "r32float",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    // const arrayBuffer = new Float32Array(heightData);\n    return { texture: heightTextureSet, data: heightData};\n  }\n\n  function setTerrainTexture(mesh)\n  {\n    writableTexture = device.createTexture({\n      size: [mesh.width-1, mesh.height-1, 1],\n      format: \'rgba32float\', // Adjust based on your requirements\n      usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.STORAGE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n  }\n\n\n  let color = await setColorTexture(terrainParams.terrain.textureFilename);\n  device.queue.copyExternalImageToTexture(\n    { source: color.image },\n    { texture: color.texture },\n    [color.image.width, color.image.height]\n  );\n\n\n  let height = await setHeightTexture(terrainParams.terrain.terrainFilename);\n  device.queue.writeTexture(\n    { texture: height.texture },\n    height.data,\n    {bytesPerRow:numberArray[0]*4},\n    { width: numberArray[0], height: numberArray[1] }\n  );\n\n  let heightChanged = false;\n  let colorChanged = false;\n  terrainFolder.add(terrainParams, \'terrain\',Object.values(terrainOptions).map(option => option.name)).name("Select Terrain")\n  .setValue(terrainOptions.everestTerrain.name)\n  .onChange(async function (value) {\n      terrainParams.terrain = Object.values(terrainOptions).find(option => option.name === value);\n      mesh = await getTerrainMesh(terrainParams.terrain.terrainFilename, terrainParams.terrain.configurationParams.terrainSkip, terrainParams.terrain.configurationParams.terrainDataNormalizeFactor);\n      terrainCells = await getTerrainCells(mesh);\n      height = await setHeightTexture(terrainParams.terrain.terrainFilename);\n      color = await setColorTexture(terrainParams.terrain.textureFilename);\n      cellArray = getCellArray(terrainCells);\n      cellBuffer = await setCellBuffer(terrainCells);\n      setTerrainTexture(mesh);\n\n      for (let i = 0; i < terrainCellsDebugIndex.length; i++) {\n        const currIndex = terrainCellsDebugIndex[i];\n      //   console.log("Terrain Cell: " + currIndex)\n      //   console.log("P0: " + " " + terrainCells.P0[currIndex]);\n      //   console.log("P1: " + " " + terrainCells.P1[currIndex]);\n      //   console.log("P2: " + " " + terrainCells.P2[currIndex]);\n      //   console.log("P3: " + " " + terrainCells.P3[currIndex]);\n      //   console.log("Aspect: " + " " + terrainCells.Aspect[currIndex]);\n        console.log("Inclination: " + " " + terrainCells.Inclination[currIndex]);\n        console.log("Altitude: " + " " + terrainCells.Altitude[currIndex]);\n      //   // console.log("Latitude: " + i + " " + terrainCells.Latitude[i]);\n      //   console.log("Area: " + " " + terrainCells.Area[currIndex]);\n        console.log("AreaXZ: " + " " + terrainCells.AreaXZ[currIndex]);\n      //   // console.log("SnowWaterEquivalent: " + i + " " + terrainCells.SnowWaterEquivalent[i]);\n      //   // console.log("InterpolatedSWE: " + i + " " + terrainCells.InterpolatedSWE[i]);\n      //   // console.log("SnowAlbedo: " + i + " " + terrainCells.SnowAlbedo[i]);\n      //   // console.log("DaysSinceLastSnowfall: " + i + " " + terrainCells.DaysSinceLastSnowfall[i]);\n      //   console.log("Curvature: " + " " + terrainCells.Curvature[currIndex]);\n      // // }\n      }\n\n      console.log("cellBuffer.size: " + cellBuffer.size);\n      sizeParams.heightMul = terrainParams.terrain.configurationParams.heightMul;\n      sizeParams.gridSize = terrainParams.terrain.configurationParams.gridSize;\n      sizeFolder.updateDisplay();\n      constantsParams.k_m = terrainParams.terrain.configurationParams.k_mScaleFactor;\n      constantsParams.meltFactor = terrainParams.terrain.configurationParams.meltFactor;\n      constantsFolder.updateDisplay();\n      weatherParams.guiTemperature = terrainParams.terrain.configurationParams.defaultTemperature;\n      weatherFolder.updateDisplay();\n      resetParams.resetSimulation();\n      camera = setCamera(terrainParams.terrain.cameraDefaults.position, terrainParams.terrain.cameraDefaults.target);\n      colorChanged = true;\n      heightChanged = true;\n    });\n  // Can\'t get this to be set by default so doing it here\n  terrainParams.terrain = terrainOptions.everestTerrain;\n\n    // //const response = await fetch(\'../assets/img/file/k2-h.tif\');\n    // //const response = await fetch(\'../assets/img/Di-3d.png\');\n    // //const url = \'../assets/img/file/everest.tif\';\n    // const url = \'../assets/img/file/k2-h.tif\';\n    // const heightData = await getHeightData(url);\n    \n    // console.log("heightdata test");\n    // console.log("heightData: " + heightData[0]);\n\n    // heightTexture = device.createTexture({\n    //   size: [numberArray[0], numberArray[1],1],\n    //   format: "r32float",\n    //   usage:\n    //     GPUTextureUsage.TEXTURE_BINDING |\n    //     GPUTextureUsage.COPY_DST |\n    //     GPUTextureUsage.RENDER_ATTACHMENT,\n    // });\n    // const arrayBuffer = new Float32Array(heightData);\n    // device.queue.writeTexture(\n    //   { texture: heightTexture },\n    //   heightData,\n    //   {bytesPerRow:numberArray[0]*4},\n    //   { width: numberArray[0], height: numberArray[1] }\n    // );\n  // }\n  console.log("amount of mesh:"+(height.texture.width-1)*(height.texture.height-1));\n  //heightTexture=cubeTexture;\n  const uniformArray = new Float32Array([0.1, 0.1]);\n  const gridBuffer = device.createBuffer({\n    label: "Grid Uniforms",\n    size: uniformArray.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  device.queue.writeBuffer(gridBuffer, 0, uniformArray);\n  let uniformBindGroup = device.createBindGroup({\n    layout: renderPipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer,\n        },\n      },\n      {\n        binding: 1,\n        resource: writableTexture.createView(),\n      },\n      {\n        binding: 2,\n        resource: color.texture.createView(),\n      },\n      {\n        binding: 3,\n        resource: {\n          buffer: gridBuffer,\n        }\n      },\n      {\n        binding: 4,\n        resource: height.texture.createView(),\n      },\n      {\n        binding: 5,\n        resource: {\n          buffer: maxBuffer,\n        }\n      }\n    ],\n  });\n\n  const renderPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: undefined, // Assigned later\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: \'clear\',\n        storeOp: \'store\',\n      },\n    ],\n    depthStencilAttachment: {\n      view: depthTexture.createView(),\n\n      depthClearValue: 1.0,\n      depthLoadOp: \'clear\',\n      depthStoreOp: \'store\',\n      stencilClearValue: 0,\n      stencilLoadOp: \'clear\',\n      stencilStoreOp: \'store\',\n    },\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Simulation compute pipeline\n  //////////////////////////////////////////////////////////////////////////////\n  const simulationParams = {\n    simulate: true,\n    deltaTime: 0.04,\n  };\n\n  const simulationUBOBufferSize =\n    7 * 4 + // simulationCS\n    1 * 4 + // padding\n    4 * 4 + // simulationCSVar\n    8 * 4 + // configurationCS\n    2 * 4 + // weatherData: temp+perci\n    2 * 4 + // padding\n    0;\n  const simulationUBOBuffer = device.createBuffer({\n    size: simulationUBOBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  // let simulationFolder = gui.addFolder(\'Simulation\');\n  // Object.keys(simulationParams).forEach((k) => {\n  //   simulationFolder.add(simulationParams, k);\n  // });\n\n  const computePipeline = device.createComputePipeline({\n    layout: \'auto\',\n    compute: {\n      module: device.createShaderModule({\n        code: particleWGSL,\n      }),\n      entryPoint: \'simulate\',\n    },\n  });\n  let computeBindGroup = device.createBindGroup({\n    layout: computePipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: simulationUBOBuffer,\n        },\n      },\n      {\n        binding: 1,\n        resource: {\n          buffer: cellBuffer,\n          offset: 0,\n          size: terrainCells.Size * cellInstanceByteSize,\n        },\n      },\n      {\n        binding: 2,\n        resource: color.texture.createView(),\n      },\n      {\n        binding: 3,\n        //resource: cubeTexture.createView(),\n        resource: writableTexture.createView({\n            format: \'rgba32float\',\n            dimension: \'2d\',\n          }\n        ),\n      },\n      {\n        binding: 4,\n        resource: {\n          buffer: maxBuffer,\n        }\n      },\n    ],\n  });\n\n  const aspect = canvas.width / canvas.height;\n  const projection = mat4.perspective((2 * Math.PI) / 5, aspect, 1, 100.0);\n  const view = mat4.create();\n  const mvp = mat4.create();\n\n  const projectionMatrix = mat4.perspective(\n    (2 * Math.PI) / 5,\n    aspect,\n    1,\n    15000.0\n  );\n\n  const modelViewProjectionMatrix = mat4.create();\n\n  function getModelViewProjectionMatrix(deltaTime: number) {\n    const viewMatrix = camera.update(deltaTime, inputHandler());\n    mat4.multiply(projectionMatrix, viewMatrix, modelViewProjectionMatrix);\n    return modelViewProjectionMatrix as Float32Array;\n  }\n\n  let lastFrameMS = Date.now();\n  let lastDayMS = Date.now()\n  let weatherData = getWeatherData(lastFrameMS, 2, 2);\n\n  function frame() {\n    // Sample is no longer the active page.\n    // console.log("loading");\n    if (!pageState.active) return;\n    const now = Date.now();\n    const deltaTime = (now - lastFrameMS) / 1000;\n    const deltaTimeFull = now - lastDayMS;\n    lastFrameMS = now;\n    if (statsParams.showStats)\n    {\n      if (statsParams.showMemoryUsage)\n      {\n        stats.showPanel(2);\n      }\n      else\n      {\n        stats.showPanel(0);\n      }\n    }\n    else\n    {\n      stats.showPanel(3)\n    }\n\n\n    // Update camera\n    const viewMatrix = camera.update(deltaTime, inputHandler());\n\n    // Render skybox\n    const skyboxViewMatrix = mat4.clone(viewMatrix);\n    skyboxViewMatrix[12] = 0; // Remove translation component\n    skyboxViewMatrix[13] = 0;\n    skyboxViewMatrix[14] = 0;\n    \n\n    //const viewMatrix = camera.update(deltaTime, inputHandler());\n    // Render the skybox\n    //renderSkybox(device, canvas, viewMatrix, projectionMatrix);\n    //TODO: how to bind weather Data per frame\n    if (getNumDaysPassed(deltaTimeFull) >= 1 && !weatherParams.useGuiWeather)\n    {\n      console.log("day of year: " + getDayOfYear(now));\n      lastDayMS = now;\n      weatherData = getWeatherData(now, mesh.width, mesh.height);\n      console.log("weatherData: " + weatherData.temperature[0] + " : " + weatherData.precipitation[0]);\n\n    }\n\n    if (now % 1000 > 998)\n    {\n      // weatherData = getWeatherData(now, mesh.width, mesh.height);\n      \n      // for (let i = 0; i < 10; i++) {\n      //   console.log("now: " + now);\n      //   console.log("day of year: " + getDayOfYear(now));\n      //   console.lSog("weather for cell: " + (i * 20));\n        // console.log("temperature: " + weatherData.temperature[i * 20]);\n        // console.log("temperature: " + weatherData.temperature[20]);\n      //   console.log("precipitation: " + weatherData.precipitation[i * 20]);\n      // }\n    }\n    if (heightChanged)\n    {\n      device.queue.writeTexture(\n        { texture: height.texture },\n        height.data,\n        {bytesPerRow:numberArray[0]*4},\n        { width: numberArray[0], height: numberArray[1] }\n      );\n      uniformBindGroup = device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: uniformBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: writableTexture.createView(),\n          },\n          {\n            binding: 2,\n            resource: color.texture.createView(),\n          },\n          {\n            binding: 3,\n            resource: {\n              buffer: gridBuffer,\n            }\n          },\n          {\n            binding: 4,\n            resource: height.texture.createView(),\n          },\n          {\n            binding: 5,\n            resource: {\n              buffer: maxBuffer,\n            }\n          }\n        ],\n      });\n      computeBindGroup = device.createBindGroup({\n        layout: computePipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: simulationUBOBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: {\n              buffer: cellBuffer,\n              offset: 0,\n              size: terrainCells.Size * cellInstanceByteSize,\n            },\n          },\n          {\n            binding: 2,\n            resource: color.texture.createView(),\n          },\n          {\n            binding: 3,\n            //resource: cubeTexture.createView(),\n            resource: writableTexture.createView({\n                format: \'rgba32float\',\n                dimension: \'2d\',\n              }\n            ),\n          },\n          {\n            binding: 4,\n            resource: {\n              buffer: maxBuffer,\n            }\n          },\n        ],\n      });\n      resetTerrainBufferMapping(device, cellArray, cellBuffer);\n      heightChanged = false;\n    }\n\n    if (colorChanged)\n    {\n      device.queue.copyExternalImageToTexture(\n        { source: color.image },\n        { texture: color.texture },\n        [color.image.width, color.image.height]\n      );\n      uniformBindGroup = device.createBindGroup({\n        layout: renderPipeline.getBindGroupLayout(0),\n        entries: [\n          {\n            binding: 0,\n            resource: {\n              buffer: uniformBuffer,\n            },\n          },\n          {\n            binding: 1,\n            resource: writableTexture.createView(),\n          },\n          {\n            binding: 2,\n            resource: color.texture.createView(),\n          },\n          {\n            binding: 3,\n            resource: {\n              buffer: gridBuffer,\n            }\n          },\n          {\n            binding: 4,\n            resource: height.texture.createView(),\n          },\n          {\n            binding: 5,\n            resource: {\n              buffer: maxBuffer,\n            }\n          }\n        ],\n      });\n      colorChanged = false;\n    }\n\n    device.queue.writeBuffer(\n      simulationUBOBuffer,\n      0,\n      new Float32Array([\n        terrainCells.MinAltitude,\n        constantsParams.tSnowA,\n        constantsParams.tSnowB,\n        constantsParams.tMeltA,\n        constantsParams.tMeltB,\n        constantsParams.k_e,\n        constantsParams.k_m,\n        constantsParams.meltFactor,\n        constantsParams.timesteps,\n        constantsParams.currentSimulationStep,\n        constantsParams.hourOfDay,\n        constantsParams.dayOfYear,\n        terrainParams.terrain.configurationParams.posNormalizeFactor,\n        terrainParams.terrain.configurationParams.posMax,\n        terrainParams.terrain.configurationParams.colorMaxScaleFactor,\n        terrainParams.terrain.configurationParams.areaScaleFactor,\n        terrainParams.terrain.configurationParams.r_i_tScaleFactor,\n        terrainParams.terrain.configurationParams.maxSWE,\n        terrainParams.terrain.configurationParams.temperatureLapseNormalizeFactor,\n        terrainParams.terrain.configurationParams.precipitationLapseNormalizeFactor,\n        weatherParams.useGuiWeather ? weatherParams.guiTemperature : weatherData.temperature[0], //TODO: bind weather Data temperature per frame\n        weatherParams.useGuiWeather ? weatherParams.guiPrecipitation : weatherData.precipitation[0], //TODO: bind weather Data percipitation per frame\n        0.0,\n        0.0,\n      ])\n    );\n    // if (now % 1000 > 998)\n    // {\n    //   if (weatherParams.useGuiWeather)\n    //   {\n    //     console.log("use gui weather");\n    //     computeSnowCPU(terrainCells, constantsParams, weatherParams.guiTemperature, weatherParams.guiPrecipitation);\n    //   }\n    //   else\n    //   {\n    //     computeSnowCPU(terrainCells, constantsParams);\n    //   }\n    // }\n\n    mat4.identity(view);\n    mat4.translate(view, vec3.fromValues(0, 0, -3), view);\n    mat4.rotateX(view, Math.PI * -0.2, view);\n    mat4.multiply(projection, view, mvp);\n\n    const cameraViewProj = getModelViewProjectionMatrix(deltaTime);\n    device.queue.writeBuffer(\n      uniformBuffer,\n      0,\n      cameraViewProj.buffer,\n      cameraViewProj.byteOffset,\n      cameraViewProj.byteLength\n    )\n\n    // prettier-ignore\n    device.queue.writeBuffer(\n      uniformBuffer,\n      64,\n      new Float32Array([\n        camera.position[0], camera.position[1], camera.position[2], // right\n        fogParams.fogStartDist, // padding //fogstart\n        view[5], view[9], fogParams.fogEndDist,// up //fogend\n        sizeParams.heightMul, // heightMul\n        terrainParams.terrain.configurationParams.posNormalizeFactor,\n        terrainParams.terrain.configurationParams.posMax,\n        terrainParams.terrain.configurationParams.colorMaxScaleFactor,\n        terrainParams.terrain.configurationParams.areaScaleFactor,\n        terrainParams.terrain.configurationParams.r_i_tScaleFactor,\n        terrainParams.terrain.configurationParams.maxSWE,\n        terrainParams.terrain.configurationParams.temperatureLapseNormalizeFactor,\n        terrainParams.terrain.configurationParams.precipitationLapseNormalizeFactor,\n      ])\n    );\n\n    device.queue.writeBuffer(gridBuffer, 0, new Float32Array([sizeParams.gridSize, sizeParams.gridSize]));\n\n\n    let maxArray = new Uint32Array([0,0,0,0]);\n\n    device.queue.writeBuffer(\n      maxBuffer,\n      0,\n      maxArray.buffer,\n      maxArray.byteOffset,\n      maxArray.byteLength\n    );\n    \n    const swapChainTexture = context.getCurrentTexture();\n    // prettier-ignore\n    renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView();\n    \n    if (statsParams.showStats) {\n      stats.begin();\n    }\n\n      \n    const commandEncoder = device.createCommandEncoder();\n    \n    {\n      const passEncoder = commandEncoder.beginComputePass();\n      passEncoder.setPipeline(computePipeline);\n      passEncoder.setBindGroup(0, computeBindGroup);\n      passEncoder.dispatchWorkgroups(Math.ceil((mesh.width-1) / 8),Math.ceil((mesh.height-1) / 8));\n      passEncoder.end();\n    }\n    {\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setPipeline(renderPipeline);\n      passEncoder.setBindGroup(0, uniformBindGroup);\n      passEncoder.setVertexBuffer(0, vertexBuffer);\n      passEncoder.draw(6,(height.texture.width-1)*(height.texture.height-1));//(heightTexture.width-1)*(heightTexture.height-1)\n      renderSkybox(device, skyboxPipeline, skyboxVerticesBuffer, skyboxUniformBuffer, skyboxUniformBindGroup,passEncoder,cameraViewProj);\n      passEncoder.end();\n    }\n    \n    device.queue.submit([commandEncoder.finish()]);\n\n    requestAnimationFrame(frame);\n    if (statsParams.showStats) {\n      stats.end()\n    }\n  }\n  requestAnimationFrame(frame);\n};\n\nconst Particles: () => JSX.Element = () =>\n  makeSample({\n    name: \'snowAccmulation\',\n    description:\n      \'This is real-time snow accumulation on terrein based on real data\',\n    gui: true,\n    stats: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      {\n        name: \'./particle.wgsl\',\n        contents: particleWGSL,\n        editable: true,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default Particles;'},{name:"./particle.wgsl",contents:f,editable:!0}],filename:C})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5",sourceFileNav:"SampleLayout_sourceFileNav__9Hf73",sourceFileContainer:"SampleLayout_sourceFileContainer__9iti6"}}}]);